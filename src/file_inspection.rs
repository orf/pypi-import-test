use anyhow::Result;
use content_inspector::{inspect, ContentType};
use git2::{ObjectType, Odb, Oid};

use std::io;
use std::io::{BufRead, Read};

const KB: u64 = 1024;
const MB: u64 = 1024 * KB;
const MAX_FILE_SIZE: u64 = 5 * MB;

pub fn write_archive_entry_to_odb<R: Read>(
    path: &str,
    size: u64,
    mut reader: &mut R,
    odb: &Odb,
) -> Result<Option<Oid>> {
    let mut first = [0; 1024];
    let n = reader.read(&mut first[..])?;
    let first = &first[..n];
    let content_type = inspect(first);
    if content_type == ContentType::BINARY {
        return Ok(None);
    }
    // Pyarmor files are just big bundles of bytecode. This isn't helpful and causes
    // large repositories. They appear to always start with this token.
    if first.starts_with("__pyarmor".as_ref()) {
        return Ok(None);
    }
    // Ignore git LFS files
    if first.starts_with("version https://git-lfs".as_ref()) {
        return Ok(None);
    }

    // pulumi_azure_native contains some very big auto-generated files called _inputs.py
    // and outputs.py. Specifically disable these.
    if path.ends_with("_inputs.py") || path.ends_with("outputs.py") {
        let needle = b"WARNING: this file was generated by the Pulumi SDK Generator.";
        if first.windows(needle.len()).any(|window| window == needle) {
            return Ok(None);
        }
    }

    let mut vec = Vec::with_capacity(size as usize);
    vec.extend_from_slice(first);
    io::copy(&mut reader, &mut vec)?;

    // The areixio package contains very large python files that contain some kind of obfuscated
    // bytecode. We skip these, and potentially others in general, by detecting if the file have
    // very few lines but are comparatively large.
    let num_lines = vec.lines().count();
    if num_lines < 5 && size >= 50 * KB {
        return Ok(None);
    }

    // let object_hash = Oid::hash_object(ObjectType::Blob, &vec).unwrap();
    // Does the object exist already? Not thread safe, obviously.
    // if odb.exists_ext(object_hash, OdbLookupFlags::NO_REFRESH) {
    //     return Ok(None);
    // }
    Ok(Some(odb.write(ObjectType::Blob, &vec)?))
}

pub fn skip_archive_entry(name: &str, size: u64) -> bool {
    if !(1..=MAX_FILE_SIZE).contains(&size) {
        return true;
    }

    if !name.ends_with(".py") {
        return true;
    }
    false
}
